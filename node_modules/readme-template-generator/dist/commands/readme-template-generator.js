"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }




const command = {
  name: 'readme-template-generator',
  description: 'Generate README file in current work directory',
  run: async (toolbox) => {
    const {
      existingFiles,
      itemURL,
      question,
      generateFile,
      isWebURL,
      showBanner,
      githubRepoInfo,
      filesystem: { read },
      print,
      parameters: { options },
    } = toolbox

    showBanner({ text: 'Readme|Template Generator' })

    print.warning(
      'Project under development, this is a beta version!\n' +
        'Contribute: https://github.com/Mikael-R/readme-template-generator\n'
    )

    if (existingFiles('README.md').indexOf('README.md') !== -1) {
      const overwrite = await question({
        type: 'list',
        prefix: 'ðŸ“¢',
        message: 'Already exists a README.md file, overwrite it?',
        choices: ['Yes', 'No'],
        customReturn: (value) => value === 'Yes',
      })

      if (!overwrite) process.exit(0)
    }

    const packageJSON = JSON.parse(
      read(`${process.cwd()}/package.json`) || '{}'
    )

    const githubRepoURL = await question({
      prefix: 'ðŸŽ¥',
      message: 'Repository URL in GitHub (recommend not skip):',
      defaultValue:
        githubRepoInfo.url.inCWD() ||
        githubRepoInfo.url.format(_optionalChain([packageJSON, 'optionalAccess', _ => _.repository, 'access', _2 => _2.url])),
      validate: (value) => {
        if (
          value === '' ||
          githubRepoInfo.url.test(`https://github.com/${value}`)
        )
          return true

        return 'Invalid GitHub repository URL'
      },
      customReturn: (value) => {
        if (githubRepoInfo.url.test(value) || value === '') return value
        return githubRepoInfo.url.format(`https://github.com/${value}`)
      },
    })

    const spinner =
      githubRepoURL && print.spin('Getting information about repository...')

    const githubRepository = await githubRepoInfo.information(
      itemURL(githubRepoURL, 2),
      itemURL(githubRepoURL, 1)
    )

    if (_optionalChain([githubRepository, 'access', _3 => _3.api, 'access', _4 => _4.index, 'optionalAccess', _5 => _5.fork])) {
      _optionalChain([spinner, 'optionalAccess', _6 => _6.warn, 'call', _7 => _7(
        'Repository informed its a fork, use origin for newsletter information'
      )])
    } else if (!githubRepository.haveConnection) {
      _optionalChain([spinner, 'optionalAccess', _8 => _8.fail, 'call', _9 => _9('Repository not found, verify wi-fi connection')])
    } else if (githubRepository.api.index) {
      _optionalChain([spinner, 'optionalAccess', _10 => _10.succeed, 'call', _11 => _11(
        'Repository information found with success in GitHub API'
      )])
    } else {
      _optionalChain([spinner, 'optionalAccess', _12 => _12.fail, 'call', _13 => _13('Repository not found in GitHub API')])
    }

    const badges = {
      toSelect: [],
      selected: [],
      exists: badgeName => badges.selected.indexOf(badgeName) !== -1,
    }

    const projectName = await question({
      prefix: 'ðŸ‘‹',
      message: 'Project name:',
      defaultValue:
        githubRepository.name ||
        _optionalChain([itemURL, 'call', _14 => _14(_optionalChain([packageJSON, 'optionalAccess', _15 => _15.repository, 'optionalAccess', _16 => _16.url]), 1), 'optionalAccess', _17 => _17.split, 'call', _18 => _18('.'), 'access', _19 => _19[0]]) ||
        _optionalChain([packageJSON, 'optionalAccess', _20 => _20.name]) ||
        itemURL('.', 1),
    })

    const status =
      await question({
        type: 'list',
        prefix: 'ðŸš§',
        message: 'Project status:',
        choices: ['Development', 'Production', 'Finished', 'Skip'],
        customReturn: (value) => {
          if (value === 'Skip' || value === 'Finished') return ''
          return value.toLowerCase()
        },
      })

    const description = await question({
      prefix: 'ðŸ“',
      message: 'Write a short description about project:',
      defaultValue:
        _optionalChain([githubRepository, 'access', _21 => _21.api, 'access', _22 => _22.index, 'optionalAccess', _23 => _23.description]) || _optionalChain([packageJSON, 'optionalAccess', _24 => _24.description]),
      validate: (value) =>
        value === '' ? 'Description its necessary' : true,
    })

    if (githubRepository.url) {
      badges.toSelect.push(
        'Language Most Used',
        'Implementations',
        'Gitpod',
        'Repository Social Status',
        'License',
        'Last Commit',
        'Repository Size'
      )
    }

    if (!_optionalChain([packageJSON, 'optionalAccess', _25 => _25.private])) {
      badges.toSelect.push('NPM Version', 'NPM Monthly Downloads')
    }

    githubRepository.api.index.homepage = await question({
      prefix: 'ðŸ¡',
      message: 'Home page URL (use empty value to skip):',
      defaultValue: _optionalChain([githubRepository, 'access', _26 => _26.api, 'access', _27 => _27.index, 'optionalAccess', _28 => _28.homepage]),
      validate: (value) => {
        if (value === '' || isWebURL(value)) return true
        return 'Invalid URL'
      },
    })

    const herokuUrl = await question({
      prefix: 'ðŸ”—',
      message: 'Heroku URL (use empty value to skip):',
      validate: (value) => {
        if (value === '') return true
        if (isWebURL(value)) {
          badges.toSelect.push('Heroku')
          return true
        }
        return 'Invalid URL'
      },
    })

    const replitUrl = await question({
      prefix: 'ðŸ”—',
      message: 'Repl.it URL (use empty value to skip):',
      validate: (value) => {
        if (value === '') return true
        if (isWebURL(`https://${value}.repl.run`)) {
          badges.toSelect.push('Repl.it')
          return true
        }
        return 'Invalid URL'
      },
      customReturn: (value) =>
        value !== '' ? `https://${value}.repl.run` : value,
    })

    const logo = await question({
      prefix: 'ðŸŽ´',
      message: 'Logo image URL or path (use empty value to skip):',
      validate: (value) => {
        if (
          value === '' ||
          isWebURL(value) ||
          existingFiles(itemURL(value, 1), value.replace(itemURL(value, 1), ''))
            .length
        )
          return true
        return 'Value informed not is URL/Path valid'
      },
    })

    const images = {
      logo,
      screenshots: [],
    }

    while (true) {
      const screenshot = await question({
        prefix: 'ðŸŒˆ',
        message:
          'GIF/image URL or path for screenshots (use empty value to skip):',
        validate: (value) => {
          if (
            value === '' ||
            isWebURL(value) ||
            existingFiles(
              itemURL(value, 1),
              value.replace(itemURL(value, 1), '')
            ).length
          )
            return true
          return 'Value informed not is URL/Path valid'
        },
      })

      if (!screenshot) break

      images.screenshots.push(screenshot)
    }

    const about = await question({
      type: 'editor',
      prefix: 'ðŸ“ƒ',
      message: 'Write about project (use empty value to skip):',
    })

    const howToUse = await question({
      type: 'editor',
      prefix: 'ðŸ¤”',
      message: 'Inform how to use project:',
      defaultValue: '#### ðŸ’» Desktop\n\n\n\n#### ðŸŒ Online',
      validate: (value) =>
        value === '' ? 'Information how to use its necessary' : true,
    })

    const technologies = []

    while (true) {
      const tech = await question({
        prefix: 'ðŸš€',
        message: 'List project technologies (use empty value to skip):',
      })

      if (!tech) break

      technologies.push(tech)
    }

    const requirements = []

    while (true) {
      const requirement = await question({
        prefix: 'ðŸŒ±',
        message:
          'List a minimal requirements to run project (use empty value to skip):',
      })

      if (!requirement) break

      requirements.push(requirement)
    }

    const features = {
      exists: false,
      finished: [],
      pendent: [],
    }

    while (true) {
      const finished = await question({
        prefix: 'ðŸŽ‡',
        message: 'List project features finished (use empty value to skip):',
      })

      if (!finished) break

      features.finished.push(finished)
    }

    while (true) {
      const pendent = await question({
        prefix: 'ðŸŽ†',
        message: 'List project features pendents (use empty value to skip):',
      })

      if (!pendent) break

      features.pendent.push(pendent)
    }

    features.exists = !!features.finished.length || !!features.pendent.length

    const contribute = {
      tutor: {
        show: false,
      },
      contributors: {
        users: [],
        show: false,
      },
    }

    contribute.tutor.show =
      githubRepository.url &&
      (await question({
        type: 'list',
        prefix: 'ðŸ’¡',
        message: 'Add tutor how to contribute for this project?',
        choices: ['Yes', 'No'],
        customReturn: (value) => value === 'Yes',
      }))

    contribute.contributors.users =
      _optionalChain([githubRepository, 'access', _29 => _29.api, 'access', _30 => _30.contributors
, 'optionalAccess', _31 => _31.filter, 'call', _32 => _32(contributor => contributor.type === 'User')
, 'access', _33 => _33.sort, 'call', _34 => _34((a, b) => b.contributions - a.contributions)]) || []

    contribute.contributors.show =
      contribute.contributors.users.length &&
      (await question({
        type: 'list',
        prefix: 'ðŸ¤—',
        message: 'Add contributors profile?',
        choices: ['Yes', 'No'],
        customReturn: (value) => value === 'Yes',
      }))

    const author = {
      exists: false,
      name: _optionalChain([packageJSON, 'optionalAccess', _35 => _35.author]),
      github: githubRepository.author,
      twitter: '',
      website: '',
      linkedin: '',
    }

    author.name = await question({
      prefix: 'ðŸ¤“',
      message: `Author full name${
        !author.name ? ' (use empty value to skip)' : ''
      }:`,
      defaultValue: author.name,
    })

    author.github = await question({
      prefix: 'ðŸ‘¤',
      message: `Author GitHub username${
        !author.github ? ' (use empty value to skip)' : ''
      }:`,
      defaultValue: author.github,
    })

    author.twitter = await question({
      prefix: 'ðŸ‘¤',
      message: 'Author twitter username (use empty value to skip):',
      validate: (value) => {
        if (value !== '') badges.toSelect.push('Author Twitter')
        return true
      },
    })

    author.linkedin = await question({
      prefix: 'ðŸ‘¤',
      message: 'Author LinkedIn username (use empty value to skip):',
    })

    author.website = await question({
      prefix: 'ðŸ‘¤',
      message: 'Author website (use empty value to skip):',
      validate: (value) => {
        if (value === '' || isWebURL(value)) return true
        return 'Invalid URL'
      },
    })

    if (
      author.name ||
      author.website ||
      author.twitter ||
      author.github ||
      author.linkedin
    )
      author.exists = true

    badges.selected = await question({
      type: 'checkbox',
      prefix: 'ðŸ“›',
      message: 'Select badges for use:',
      choices: badges.toSelect,
      customReturn: (
        value // convert to lowercase and remove spaces
      ) => value.map(badge => badge.toLowerCase().replace(/\s/g, '')),
    })

    const license = {
      name:
        _optionalChain([githubRepository, 'access', _36 => _36.api, 'access', _37 => _37.index, 'optionalAccess', _38 => _38.license, 'access', _39 => _39.name]) ||
        _optionalChain([read, 'call', _40 => _40('LICENSE'), 'optionalAccess', _41 => _41.split, 'call', _42 => _42('\n'), 'access', _43 => _43[0], 'optionalAccess', _44 => _44.trim, 'call', _45 => _45()]) ||
        _optionalChain([packageJSON, 'optionalAccess', _46 => _46.license]),
      url:
        _optionalChain([githubRepository, 'access', _47 => _47.api, 'access', _48 => _48.index, 'optionalAccess', _49 => _49.license, 'access', _50 => _50.url]) ||
        (githubRepository.url &&
          read('LICENSE') &&
          `${githubRepository.url}/blob/master/LICENSE`),
    }

    license.name = await question({
      prefix: 'ðŸ”',
      message: `Project license name${
        !license.name ? ' (use empty value to skip)' : ''
      }:`,
      defaultValue: license.name,
    })

    license.url = await question({
      prefix: 'ðŸ”',
      message: `Project license URL${
        !license.name ? ' (use empty value to skip)' : ''
      }:`,
      defaultValue: license.url,
      validate: (value) =>
        license.name && value === '' ? `License URL for ${license.name}` : true,
    })

    generateFile({
      template: 'README.md.ejs',
      target: options.pathTarget || options.p || 'README.md',
      props: {
        projectName,
        badges,
        githubRepository,
        herokuUrl,
        replitUrl,
        packageJSON: packageJSON,
        status,
        images,
        description,
        about,
        howToUse,
        technologies,
        requirements,
        features,
        contribute,
        author,
        license,
      },
    })
      .then(() =>
        print.success('\nGenerated README.md file with success in current dir!')
      )
      .catch(error => print.error(error.message))
  },
}

exports. default = command
